#IDAStar function Iterative deepening A*#f(x) = manhattan distance + g(x) #g(x) is the cost to travel from the root to current node #manhattan distance is is a problem-specific heuristic estimate of the cost to travel from n to the goal.#nextNode function as a parameter go in IDAStar function#moveNum variable is to calculate the number of calls functiondef IDAStar (initial,nextNode,goal = [[1, 2, 3], [4, 5, 6], [7, 8, 0]],moveNum=0):    def DFS(paths,sValue):        nonlocal fValue        nonlocal moveNum        if paths[-1] == goal:            return paths        for subNodes in nextNode(paths[-1]):            moveNum += 1            if subNodes not in paths:                fDistance = manfDistancetance(subNodes) + len(paths)-1  # node of f(x)                if (fDistance <= sValue):           #store in paths and continue expand of next depth                      nextpaths = DFS(paths + [subNodes],sValue)                    if nextpaths:                        return nextpaths                else:                               #compare f(x) of every node and record the smallest f(x)                    if (fValue==sValue):            #the smallest f(x) is sValue of next loop                        fValue = fDistance                                            else:                        if fDistance < fValue:                            fValue = fDistance                                   #calculate the manhattan distance                         def manfDistancetance(subNode1):            num = 0            for x in range(0,3):                for y in range(0,3):                    c = subNode1[x][y]                    if c == 0:                        continue                    if (c % 3 == 0):                        a = c // 3 -1                        b = 2                        d = abs(a-x)+abs(b-y)                        num += d                    else:                         a = c // 3                        b = c % 3 - 1                        d = abs(a-x)+abs(b-y)                        num += d            return num                    #execute from here !!!!!!!!!    sValue = manfDistancetance(initial)   #define  sValue is standard f(x) every loop      fValue = 0                            #fValue will record the new f(x) or new sValue for next loop    paths = None                          #paths is the path from initial node to current node    while paths is None:                      paths = DFS([initial],sValue)         sValue = fValue                   #update the number of sValue every loop        if paths:            return paths,moveNum    def nextNode(currentNode):        #get tile 0  position    def getIndex(currentNode):        for i,j in enumerate(currentNode):            for k,l in enumerate(j):                if l == 0:                    return i,k                    #move tiles and copy tile's data     def copyNode(x1,y1):        import copy        grid = copy.deepcopy(currentNode)        grid [x1][y1], grid[x][y] = grid[x][y],grid[x1][y1]        return grid        #execute from here  !!!!!!!!    subNode = []    x,y = getIndex(currentNode)        #check which direction can move    if x > 0:        subNode.append(copyNode(x-1,y))    if y > 0:        subNode.append(copyNode(x,y-1))    if x < 2:        subNode.append(copyNode(x+1,y))    if y < 2:        subNode.append(copyNode(x,y+1))    return subNodedef main():    list1 = [[[0,7,1],[4,3,2],[8,6,5]],             [[5,6,0],[1,3,8],[4,7,2]],             [[3,5,6],[1,2,7],[0,8,4]],             [[7,3,5],[4,0,2],[8,1,6]],             [[6,4,8],[7,1,3],[0,2,5]],             [[3,2,0],[6,1,8],[4,7,5]],             [[0,1,8],[3,6,7],[5,4,2]],             [[6,4,1],[7,3,2],[0,5,8]],             [[0,7,1],[5,4,8],[6,2,3]],             [[5,4,0],[2,3,1],[8,7,6]],             [[8,6,7],[2,5,4],[3,0,1]]             ]    for list2 in list1:        import timeit        start = timeit.default_timer()        paths,moveNum = IDAStar(list2,nextNode)        print("the number of moves:",len(paths)-1)        print("the number of calls function",moveNum)        stop = timeit.default_timer()        print('Time: ', stop - start)  if __name__ == "__main__":    main()